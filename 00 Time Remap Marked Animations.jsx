// This script looks at a precomp's markers and creates keyframes for each animation using time remapping
{
    var secondsBetweenAnims = 2;
    var keyLabel1 = 8;
    var keyLabel2 = 3;

    // Iterates over every time remap marker and sets HOLD on every other to make it easier to distinguish animation-starts
    // Colorizes the keyframes such that every other pair is a different label
    function colorizeKeys(property) {
        var pair = 0;
        for (var i = 2; i <= property.numKeys; i += 1) { // Skip the first keyframe as it's the 0:0 keyframe needed for time remapping
            if (i % 2 === 0) pair += 1;
            property.setLabelAtKey(i, pair % 2 === 0 ? keyLabel1 : keyLabel2);
        }
    }

    function createKeyframes(layer, markers) {
        var timeRemap = layer.property('ADBE Time Remapping');

        // Turn on time remapping
        //var originalInPoint = layer.inPoint; // A layer can can have different inPoints depending if time remapping is enabled
        layer.timeRemapEnabled = true;
        //if (layer.inPoint !== originalInPoint) layer.inPoint = originalInPoint; // Reset the in-point to the original value
        timeRemap.removeKey(2); // Two keyframes are always generated by turning on time remapping, remove last one

        // Create keyframes for each pair of markers
        var lastEnd = layer.inPoint + secondsBetweenAnims;
        for (var i = 1; i <= markers.numKeys; i += 2) {
            var markerStart = markers.keyTime(i); // The time of the marker that signals the start of the animation
            var markerEnd = markers.keyTime(i + 1); // The time of the marker that signals the end of the animation
            var marker = markers.keyValue(i);

            if (markerStart === 0) {
                alert('"' + marker.comment + '" starts at zero. This is not allowed.');
                return;
            }

            var duration = markerEnd - markerStart; // The duration of the animation

            // Add the source marker to the layer
            if (marker.comment.length > 1) {
                layer.marker.setValueAtTime(lastEnd, marker);
            }

            timeRemap.setValueAtTime(lastEnd, markerStart);
            timeRemap.setValueAtTime(lastEnd + duration, markerEnd);

            lastEnd += secondsBetweenAnims;
            lastEnd += duration;
        }

        colorizeKeys(timeRemap);
    }

    // Main function
    function main() {
        var activeItem = app.project.activeItem;
        if (!activeItem instanceof CompItem) {
            alert('No opened composition.');
            return;
        }

        app.beginUndoGroup('Adjust Precomp Timings');

        // Create keyframes for each selected layer
        for (var i = 0; i < activeItem.selectedLayers.length; i++) {
            var selectedLayer = activeItem.selectedLayers[i];
            var precomp = selectedLayer.source;
            if (!(precomp instanceof CompItem)) continue;

            // Check markers
            var markers = precomp.markerProperty;
            if (markers.numKeys < 2 || markers.numKeys % 2 !== 0) {
                alert(
                    'The precomp must have at least two markers and an even number of markers.'
                );
                return;
            }

            // Create or refresh
            selectedLayer.timeRemapEnabled = false;
            var layerMarkers = selectedLayer.marker;
            while (layerMarkers.numKeys > 0) {
                layerMarkers.removeKey(1);
            }

            createKeyframes(selectedLayer, precomp.markerProperty);
        }

        app.endUndoGroup();
    }

    main();
}
